{"version":3,"sources":["../src/index.ts","../src/commands/add.ts","../src/utils/logger.ts","../src/utils/getConfig.ts","../src/utils/toPascalCase.ts","../src/utils/installComponent.ts","../src/utils/writeFile.ts","../src/utils/resolveComponentImports.ts","../src/utils/installPackage.ts","../src/utils/resolvePackageRequirements.ts","../src/utils/checkInstalledPackages.ts","../src/utils/registry/getComponentNames.ts","../src/utils/API/API.ts","../src/config/config.ts","../src/utils/registry/getComponents.ts","../src/commands/init.ts","../src/config/cn.ts"],"sourcesContent":["#!/usr/bin/env node\r\nimport { Command } from \"commander\";\r\nimport { add } from \"./commands/add.js\";\r\nimport { init } from \"./commands/init.js\";\r\nimport { config } from \"dotenv\";\r\n\r\nconfig({ path: \"./.env\" });\r\n\r\nasync function main() {\r\n  try {\r\n    const program = new Command()\r\n      .name(\"layers-ui\")\r\n      .description(\"Adds pre-made components to projects\")\r\n      .version(\"1.0.0\");\r\n\r\n    program.addCommand(add).addCommand(init);\r\n\r\n    program.parse(process.argv);\r\n  } catch (err) {\r\n    console.log((err as Error).message);\r\n  }\r\n}\r\n\r\nasync function test() {}\r\n\r\nif (process.argv[2] === \"test\") {\r\n  test();\r\n} else {\r\n  main();\r\n}\r\n","import { Command } from \"commander\";\r\nimport { logger } from \"../utils/logger.js\";\r\nimport { z } from \"zod\";\r\nimport { getConfig } from \"../utils/getConfig.js\";\r\nimport prompts from \"prompts\";\r\nimport { installComponent } from \"../utils/installComponent.js\";\r\nimport chalk from \"chalk\";\r\nimport ora from \"ora\";\r\nimport { installPackage } from \"../utils/installPackage.js\";\r\nimport { getComponentNames } from \"../utils/registry/getComponentNames.js\";\r\nimport { getComponents } from \"../utils/registry/getComponents.js\";\r\n\r\nconst addArgumentsSchema = z.object({\r\n  components: z.array(z.string()),\r\n});\r\n\r\nexport const add = new Command()\r\n  .name(\"add\")\r\n  .description(\"adds component to your project\")\r\n  .argument(\"[inputComponents...]\", \"components to add\")\r\n  .action(addCommand);\r\n\r\nasync function addCommand(inputComponents: string[]) {\r\n  try {\r\n    const config = await getConfig();\r\n\r\n    const options = addArgumentsSchema.parse({ components: inputComponents });\r\n\r\n    const availableComponentNames = await getComponentNames();\r\n\r\n    // Check for invalid component names\r\n    const validComponentNames: string[] = [];\r\n    const invalidComponentNames: string[] = [];\r\n\r\n    options.components.forEach((name) => {\r\n      if (availableComponentNames.includes(name)) {\r\n        validComponentNames.push(name);\r\n      } else {\r\n        invalidComponentNames.push(name);\r\n      }\r\n    });\r\n\r\n    // Display invalid component names if they exist\r\n    if (invalidComponentNames.length > 0) {\r\n      console.log(\r\n        chalk.yellow(\"Ignoring Invalid Component Names:\"),\r\n        invalidComponentNames.join(\", \")\r\n      );\r\n    }\r\n\r\n    // If user doesnt pass in a component as argument, display a prompt style menu\r\n    let selectedComponentNames = validComponentNames;\r\n    if (options.components.length <= 0) {\r\n      const { components } = await prompts({\r\n        instructions: false,\r\n        type: \"multiselect\",\r\n        hint: \"Press [space] to select, [a] to select all, [enter] to submit\",\r\n        name: \"components\",\r\n        message: \"Select components\",\r\n        choices: availableComponentNames.map((component) => {\r\n          return { title: component, value: component };\r\n        }),\r\n      });\r\n      selectedComponentNames = components;\r\n    }\r\n\r\n    if (selectedComponentNames.length <= 0) {\r\n      logger.info(\"No valid components selected, exiting.\");\r\n      return;\r\n    }\r\n\r\n    const spinner = ora(\"Retrieving components from registry... \");\r\n    const { components, dependencies, devDependencies } = await getComponents(\r\n      selectedComponentNames\r\n    );\r\n    spinner.stop();\r\n\r\n    await Promise.all(\r\n      components.map((component) => {\r\n        return installComponent(component, config, { replace: true });\r\n      })\r\n    );\r\n\r\n    // Install the necessary packages\r\n    if (dependencies.length > 0 || devDependencies.length > 0) {\r\n      const spinner = ora(\"Installing dependencies...\").start();\r\n      await installPackage({ dependencies, devDependencies });\r\n      spinner.succeed(\"Completed dependency installation\");\r\n    }\r\n  } catch (err) {\r\n    logger.error((err as Error).message);\r\n  }\r\n}\r\n","import chalk from \"chalk\";\r\n\r\nexport const logger = {\r\n  error(...args: unknown[]) {\r\n    console.log(chalk.red(...args));\r\n  },\r\n  warn(...args: unknown[]) {\r\n    console.log(chalk.yellow(...args));\r\n  },\r\n  info(...args: unknown[]) {\r\n    console.log(chalk.cyan(...args));\r\n  },\r\n  success(...args: unknown[]) {\r\n    console.log(chalk.green(...args));\r\n  },\r\n  break() {\r\n    console.log(\"\");\r\n  },\r\n};\r\n","import { z } from \"zod\";\r\nimport fs from \"fs/promises\";\r\n\r\nconst configSchema = z.object({\r\n  path: z.object(\r\n    {\r\n      utils: z.string({ message: \"utils path is missing\" }),\r\n      components: z.string({ message: \"components path is missing\" }),\r\n    },\r\n    { message: \"`path` config is missing \" }\r\n  ),\r\n  using: z.enum([\"vite\", \"cra\", \"next\"]),\r\n});\r\n\r\nexport type ConfigSchema = z.infer<typeof configSchema>;\r\n\r\n/**\r\n * Retrieves components.json file config from root directory\r\n */\r\nexport async function getConfig() {\r\n  const cwd = process.cwd();\r\n  const rawConfig = await fs.readFile(`${cwd}/components.json`, \"utf-8\");\r\n  const config = JSON.parse(rawConfig);\r\n\r\n  const validatedConfig = configSchema.safeParse(config);\r\n  if (!validatedConfig.success) {\r\n    throw new Error(\"Invalid configuration file\");\r\n  }\r\n\r\n  return validatedConfig.data;\r\n}\r\n","export function toPascalCase(input: string, delimiter: string, join?: string) {\r\n  const capitalizedWords = input\r\n    .split(delimiter)\r\n    .map((word) => `${word.split(\"\")[0].toUpperCase()}${word.slice(1)}`);\r\n  return capitalizedWords.join(join || \"\");\r\n}\r\n","import { toPascalCase } from \"./toPascalCase.js\";\r\nimport ora from \"ora\";\r\nimport path from \"path\";\r\nimport { writeFileTo } from \"./writeFile.js\";\r\nimport { resolveComponentImports } from \"./resolveComponentImports.js\";\r\nimport { ConfigSchema } from \"./getConfig.js\";\r\n\r\nexport async function installComponent(\r\n  component: {\r\n    name: string;\r\n    content: string;\r\n  },\r\n  config: ConfigSchema,\r\n  opts?: { replace?: boolean }\r\n) {\r\n  const spinner = ora(`Writing ${component.name}...`).start();\r\n\r\n  const fileName = toPascalCase(component.name, \"-\") + \".tsx\";\r\n  const successfulyWrittenFile = await writeFileTo({\r\n    path: path.resolve(process.cwd(), \".\" + config.path.components),\r\n    name: fileName,\r\n    file: resolveComponentImports(component.content, config.path),\r\n    replace: opts?.replace,\r\n  });\r\n\r\n  if (successfulyWrittenFile) {\r\n    spinner.succeed(\r\n      `Successfuly inserted ${toPascalCase(component.name, \"-\", \" \")}.`\r\n    );\r\n  } else {\r\n    spinner.stop();\r\n  }\r\n}\r\n","import fs from \"fs/promises\";\r\n\r\nexport async function fileExists(path: string) {\r\n  try {\r\n    await fs.stat(path);\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport async function writeFileTo({\r\n  path,\r\n  file,\r\n  name,\r\n  replace,\r\n}: {\r\n  path: string;\r\n  file: string;\r\n  name: string;\r\n  replace?: boolean;\r\n}) {\r\n  const pathWithFileName = `${path}/${name}`;\r\n  const fileAlreadyExists = await fileExists(pathWithFileName);\r\n  if (fileAlreadyExists && !replace) {\r\n    return false;\r\n  }\r\n\r\n  await fs.writeFile(pathWithFileName, file);\r\n  return true;\r\n}\r\n","import { ConfigSchema } from \"./getConfig.js\";\r\n\r\nexport function resolveComponentImports(\r\n  file: string,\r\n  paths: ConfigSchema[\"path\"]\r\n) {\r\n  return file\r\n    .replace(\"@/components/ui\", `${paths.components.replace(\"/src\", \"@\")}`)\r\n    .replace(\"@/utils/lib\", `${paths.utils.replace(\"/src\", \"@\")}`);\r\n}\r\n","import { execa } from \"execa\";\r\nimport { resolvePackageRequirements } from \"./resolvePackageRequirements.js\";\r\nimport { getConfig } from \"./getConfig.js\";\r\nimport { checkInstalledPackages } from \"./checkInstalledPackages.js\";\r\n\r\ntype Args = {\r\n  dependencies: string[];\r\n  devDependencies: string[];\r\n};\r\n\r\nexport async function installPackage({ dependencies, devDependencies }: Args) {\r\n  // Check if the package is installed\r\n  const installedPackages = await checkInstalledPackages();\r\n  const dependenciesToBeInstalled = dependencies.filter(\r\n    (dep) => !installedPackages.includes(dep)\r\n  );\r\n  const devDependenciesToBeInstalled = devDependencies.filter(\r\n    (dep) => !installedPackages.includes(dep)\r\n  );\r\n\r\n  // Resolve package requirements\r\n  const config = await getConfig();\r\n  dependenciesToBeInstalled.forEach((pack) =>\r\n    resolvePackageRequirements(pack, config)\r\n  );\r\n  devDependenciesToBeInstalled.forEach((pack) =>\r\n    resolvePackageRequirements(pack, config)\r\n  );\r\n\r\n  if (devDependenciesToBeInstalled.length > 0) {\r\n    await execa(\"npm\", [\"install\", \"-D\", ...devDependenciesToBeInstalled], {\r\n      cwd: process.cwd(),\r\n    });\r\n  }\r\n\r\n  if (dependenciesToBeInstalled.length > 0) {\r\n    await execa(\"npm\", [\"install\", ...dependenciesToBeInstalled], {\r\n      cwd: process.cwd(),\r\n    });\r\n  }\r\n}\r\n","import path from \"path\";\r\nimport { ConfigSchema } from \"./getConfig.js\";\r\nimport fs from \"fs/promises\";\r\n\r\nconst REACT_LOADING_SKELETON_CSS_IMPORT = `import 'react-loading-skeleton/dist/skeleton.css'`;\r\n\r\nconst list = {\r\n  \"react-loading-skeleton\": async (config: ConfigSchema) => {\r\n    if (config.using === \"vite\") {\r\n      const mainFilePath = path.resolve(process.cwd(), \"./src/main.tsx\");\r\n      const mainFile = await fs.readFile(mainFilePath, \"utf-8\");\r\n\r\n      if (!mainFile.includes(\"react-loading-skeleton/dist/skeleton.css\")) {\r\n        await fs.writeFile(\r\n          mainFilePath,\r\n          `${REACT_LOADING_SKELETON_CSS_IMPORT}\\n${mainFile}`\r\n        );\r\n      }\r\n    }\r\n    // TODO : Implement for cra and next\r\n  },\r\n};\r\n\r\n/**\r\n * Some packages like react-loading-skeleton requires the user to add a css import inside their code somewhere. This function is made to resolve those needs\r\n */\r\nexport async function resolvePackageRequirements(\r\n  packageName: string,\r\n  config: ConfigSchema\r\n) {\r\n  if (packageName in list) {\r\n    const resolver = list[packageName as keyof typeof list];\r\n    await resolver(config);\r\n  }\r\n}\r\n","import fs from \"fs/promises\";\r\nimport path from \"path\";\r\n\r\nexport async function checkInstalledPackages() {\r\n  const packageJsonPath = path.resolve(process.cwd(), \"package.json\");\r\n  const packageJson = JSON.parse(await fs.readFile(packageJsonPath, \"utf-8\"));\r\n\r\n  const installedPackages = [\r\n    ...Object.keys(packageJson.dependencies || {}),\r\n    ...Object.keys(packageJson.devDependencies || {}),\r\n  ];\r\n\r\n  return installedPackages;\r\n}\r\n","import { z } from \"zod\";\r\nimport { REGISTRY } from \"../API/API.js\";\r\n\r\nconst nameSchema = z.object({ data: z.array(z.string()) });\r\n\r\nexport async function getComponentNames() {\r\n  const response = await REGISTRY.get(\"/names\");\r\n  const names = nameSchema.parse(response?.data).data;\r\n  return names;\r\n}\r\n","import axios from \"axios\";\r\nimport { REGISTRY_URL } from \"../../config/config.js\";\r\n\r\nexport const REGISTRY = axios.create({\r\n  baseURL: REGISTRY_URL,\r\n});\r\n","export const REGISTRY_URL = \"https://layers-ui-registry.vercel.app/\";\r\n","import { z } from \"zod\";\r\nimport { REGISTRY } from \"../API/API.js\";\r\n\r\nconst registrySchema = z.object({\r\n  components: z.array(\r\n    z.object({\r\n      name: z.string(),\r\n      content: z.string(),\r\n    })\r\n  ),\r\n  dependencies: z.array(z.string()),\r\n  devDependencies: z.array(z.string()),\r\n});\r\n\r\nexport type RegistryResponse = z.infer<typeof registrySchema>;\r\n\r\nexport async function getComponents(name: string[]) {\r\n  const response = await REGISTRY.get(`?components=${name.join(\",\")}`);\r\n  const components = registrySchema.parse(response?.data);\r\n  return components;\r\n}\r\n","import { Command } from \"commander\";\r\nimport { logger } from \"../utils/logger.js\";\r\nimport prompts from \"prompts\";\r\nimport { z } from \"zod\";\r\nimport { ConfigSchema } from \"../utils/getConfig.js\";\r\nimport fs from \"fs/promises\";\r\nimport path from \"path\";\r\nimport chalk from \"chalk\";\r\nimport { fileExists } from \"../utils/writeFile.js\";\r\nimport { cnFile } from \"../config/cn.js\";\r\n\r\nconst DEFAULT_COMPONENTS_PATH = \"/src/components/ui\";\r\nconst DEFAULT_UTILS_PATH = \"/src/utils\";\r\nconst DEFAULT_UTILS_NAME = \"lib\";\r\n\r\nexport const init = new Command()\r\n  .name(\"init\")\r\n  .description(\"intialize your project to accept layer components\")\r\n  .action(initCommand);\r\n\r\nconst initInputSchema = z.object({\r\n  componentPath: z.string(),\r\n  utilsPath: z.string(),\r\n  utilsName: z.string(),\r\n  buildTool: z.enum([\"vite\", \"cra\", \"next\"]),\r\n});\r\n\r\nasync function initCommand() {\r\n  try {\r\n    const response = await prompts([\r\n      {\r\n        type: \"text\",\r\n        name: \"componentPath\",\r\n        message: \"Component install path?\",\r\n        initial: DEFAULT_COMPONENTS_PATH,\r\n      },\r\n      {\r\n        type: \"text\",\r\n        message: \"Utils file install path?\",\r\n        name: \"utilsPath\",\r\n        initial: DEFAULT_UTILS_PATH,\r\n      },\r\n      {\r\n        type: \"text\",\r\n        message: \"Utils file name?\",\r\n        name: \"utilsName\",\r\n        initial: DEFAULT_UTILS_NAME,\r\n      },\r\n      {\r\n        type: \"select\",\r\n        message: \"Which build tool are you using?\",\r\n        name: \"buildTool\",\r\n        initial: 0,\r\n        choices: [\r\n          { title: \"Vite\", value: \"vite\" },\r\n          // { title: \"Create React App\", value: \"cra\" },\r\n          // { title: \"NextJS\", value: \"next\" },\r\n        ],\r\n      },\r\n    ]);\r\n\r\n    const parsedResponse = initInputSchema.parse(response);\r\n\r\n    const cwd = process.cwd();\r\n\r\n    // Create and write config files\r\n    const config: ConfigSchema = {\r\n      path: {\r\n        components: parsedResponse.componentPath,\r\n        utils: `${parsedResponse.utilsPath}/${parsedResponse.utilsName}`,\r\n      },\r\n      using: parsedResponse.buildTool,\r\n    };\r\n    const configJSON = JSON.stringify(config, null, \"\\t\");\r\n    await fs.writeFile(path.resolve(cwd, \"./components.json\"), configJSON);\r\n\r\n    // Create path for components\r\n    const resolvedComponentPath = path.resolve(\r\n      cwd,\r\n      `.${config.path.components}`\r\n    );\r\n    if (!fs.stat(resolvedComponentPath)) {\r\n      fs.mkdir(resolvedComponentPath);\r\n    }\r\n\r\n    // Create utils file\r\n    const utilsFilePath = path.resolve(cwd, `.${config.path.utils}.ts`);\r\n    const utilsFolderPath = path.resolve(cwd, `.${parsedResponse.utilsPath}`);\r\n    if (await fileExists(utilsFilePath)) {\r\n      const { proceed: shouldOverwrite } = await prompts({\r\n        name: \"proceed\",\r\n        type: \"toggle\",\r\n        message: `The file named ${chalk.yellow(\r\n          parsedResponse.utilsName + \".tsx\"\r\n        )} at ${chalk.yellow(\r\n          parsedResponse.utilsPath\r\n        )} already exists, would like to replace it?`,\r\n        initial: true,\r\n        active: \"yes\",\r\n        inactive: \"no\",\r\n      });\r\n      if (shouldOverwrite) {\r\n        await fs.writeFile(utilsFilePath, cnFile);\r\n      }\r\n    } else {\r\n      fs.mkdir(utilsFolderPath, { recursive: true });\r\n      await fs.writeFile(utilsFilePath, cnFile);\r\n    }\r\n\r\n    logger.success(\"Successfuly initialized project.\");\r\n  } catch (err) {\r\n    logger.error((err as Error).message);\r\n  }\r\n}\r\n","export const cnFile = `import clsx, { ClassValue } from \"clsx\";\r\nimport { twMerge } from \"tailwind-merge\";\r\n\r\nexport function cn(...classNames: ClassValue[]) {\r\n  return twMerge(clsx(classNames));\r\n}\r\n`;\r\n"],"mappings":"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","names":["Command","Command","chalk","logger","args","z","z","fs","configSchema","getConfig","cwd","rawConfig","config","validatedConfig","prompts","toPascalCase","input","delimiter","join","word","ora","path","fs","fileExists","path","writeFileTo","file","name","replace","pathWithFileName","resolveComponentImports","file","paths","installComponent","component","config","opts","spinner","ora","fileName","toPascalCase","writeFileTo","path","resolveComponentImports","chalk","ora","execa","path","fs","REACT_LOADING_SKELETON_CSS_IMPORT","list","config","mainFilePath","mainFile","resolvePackageRequirements","packageName","resolver","fs","path","checkInstalledPackages","packageJsonPath","packageJson","installPackage","dependencies","devDependencies","installedPackages","checkInstalledPackages","dependenciesToBeInstalled","dep","devDependenciesToBeInstalled","config","getConfig","pack","resolvePackageRequirements","execa","z","axios","REGISTRY_URL","REGISTRY","axios","REGISTRY_URL","nameSchema","z","getComponentNames","response","REGISTRY","z","registrySchema","z","getComponents","name","response","REGISTRY","addArgumentsSchema","z","add","Command","addCommand","inputComponents","config","getConfig","options","availableComponentNames","getComponentNames","validComponentNames","invalidComponentNames","name","chalk","selectedComponentNames","components","prompts","component","logger","spinner","ora","dependencies","devDependencies","getComponents","installComponent","installPackage","err","Command","prompts","z","fs","path","chalk","cnFile","DEFAULT_COMPONENTS_PATH","DEFAULT_UTILS_PATH","DEFAULT_UTILS_NAME","init","Command","initCommand","initInputSchema","z","response","prompts","parsedResponse","cwd","config","configJSON","fs","path","resolvedComponentPath","utilsFilePath","utilsFolderPath","fileExists","shouldOverwrite","chalk","cnFile","logger","err","config","main","program","Command","add","init","err","test"]}